_G _G._G (module)\nLua _G module.
_G _G._G (table)\nA global variable (not a function) that holds the global environment\n(see §2.2). Lua itself does not use this variable; changing its value does\nnot affect any environment, nor vice versa.
abs math.abs(x)\nReturns the absolute value of `x`. (integer/float)
acos math.acos(x)\nReturns the arc cosine of `x` (in radians).
ansi_c _G.snippets.ansi_c (table)\nTable of C-specific snippets.
arshift bit32.arshift(x, disp)\nReturns the number `x` shifted `disp` bits to the right. The number `disp`\nmay be any representable integer. Negative displacements shift to the left.\n\nThis shift operation is what is called arithmetic shift. Vacant bits on the\nleft are filled with copies of the higher bit of `x`; vacant bits on the\nright are filled with zeros. In particular, displacements with absolute\nvalues higher than 31 result in zero or `0xFFFFFFFF` (all original bits are\nshifted out).\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
asin math.asin(x)\nReturns the arc sine of `x` (in radians).
assert _G.assert(v [, message])\nCalls `error` if the value of its argument `v` is false (i.e., nil or false);\notherwise, returns all its arguments. In case of error, `message` is the\nerror object; when absent, it defaults to "assertion failed!".
atan math.atan(y [, x])\nReturns the arc tangent of `y/x` (in radians), but uses the signs\nof both parameters to find the quadrant of the result. (It also handles\ncorrectly the case of `x` being zero.)\n\nThe default value for `x` is 1, so that the call `math.atan(y)` returns the\narc tangent of `y`.
atan2 math.atan2(y, x)\nReturns the arc tangent of `y/x` (in radians), but uses the signs\nof both parameters to find the quadrant of the result. (It also handles\ncorrectly the case of `x` being zero.)\n\nDeprecated in Lua 5.3.
band bit32.band(...)\nReturns the bitwise "and" of its operands.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
bit32 _G.bit32 (module)\nLua bit32 module.
bnot bit32.bnot(x)\nReturns the bitwise negation of `x`. For any integer `x`, the following\nidentity holds:\n\n  assert(bit32.bnot(x) == (-1 - x) % 2^32)\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
bor bit32.bor(...)\nReturns the bitwise "or" of its operands.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
btest bit32.btest(...)\nReturns a boolean signaling whether the bitwise "and" of its operands is\ndifferent from zero.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
buffer _G.buffer (table)\nThe current buffer in the current view.
buffer view.buffer (table)\nThe buffer the view contains. (Read-only)
byte string.byte(s [, i [, j]])\nReturns the internal numerical codes of the characters `s[i]`, `s[i+1]`,\n···, `s[j]`. The default value for `i` is 1; the default value for `j`\nis `i`. These indices are corrected following the same rules of function\n`string.sub`.\n\nNumerical codes are not necessarily portable across platforms.
ceil math.ceil(x)\nReturns the smallest integral value larger than or equal to `x`.
char string.char(···)\nReceives zero or more integers. Returns a string with length equal to\nthe number of arguments, in which each character has the internal numerical\ncode equal to its corresponding argument.\n\nNumerical codes are not necessarily portable across platforms.
char utf8.char(···)\nReceives zero or more integers, converts each one to its corresponding UTF-8\nbyte sequence and returns a string with the concatenation of all these\nsequences.\n\nNew in Lua 5.3.
charpattern utf8.charpattern (string)\nThe pattern (a string, not a function) "\0-\x7F\xC2-\xF4*"\n(see §6.4.1), which matches exactly one UTF-8 byte sequence, assuming that\nthe subject is a valid UTF-8 string.\n\nNew in Lua 5.3.
clock os.clock()\nReturns an approximation of the amount in seconds of CPU time used by\nthe program.
close file:close()\nCloses `file`. Note that files are automatically closed when their\nhandles are garbage collected, but that takes an unpredictable amount of\ntime to happen.\n\nWhen closing a file handle created with `io.popen`, `file:close` returns the\nsame values returned by `os.execute`.
close io.close([file])\nEquivalent to `file:close()`. Without a `file`, closes the default\noutput file.
close spawn_proc:close()\nCloses standard input for process *spawn_proc*, effectively sending an EOF\n(end of file) to it.
close_all_buffers io.close_all_buffers()\nCloses all open buffers, prompting the user to continue if there are unsaved\nbuffers, and returns `true` if the user did not cancel.\nNo buffers are saved automatically. They must be saved manually.\n@return `true` if user did not cancel.\n@see io.close_buffer
close_buffer io.close_buffer()\nCloses the current buffer, prompting the user to continue if there are\nunsaved changes, and returns `true` if the buffer was closed.\n@return `true` if the buffer was closed; `nil` otherwise.
codepoint utf8.codepoint(s [, i [, j]])\nReturns the codepoints (as integers) from all characters in `s` that start\nbetween byte position `i` and `j` (both included). The default for `i` is 1\nand for `j` is `i`. It raises an error if it meets any invalid byte sequence.\n\nNew in Lua 5.3.
codes utf8.codes(s)\nReturns values so that the construction\n\n    for p, c in utf8.codes(s) do *body* end\n\nwill iterate over all characters in string `s`, with `p` being the position\n(in bytes) and `c` the code point of each character. It raises an error if it\nmeets any invalid byte sequence.\n\nNew in Lua 5.3.
collectgarbage _G.collectgarbage([opt [, arg]])\nThis function is a generic interface to the garbage collector. It\nperforms different functions according to its first argument, `opt`:\n  "collect": performs a full garbage-collection cycle. This is the default\n             option.\n  "stop": stops automatic execution of the garbage collector.\n  "restart": restarts automatic execution of the garbage collector.\n  "count": returns the total memory in use by Lua in Kbytes. The value has a\n           fractional part, so that it multiplied by 1024 gives the exact\n           number of bytes in use by Lua (except for overflows).\n  "step": performs a garbage-collection step. The step "size" is controlled\n          by `arg`. With a zero value, the collector will perform one basic\n          (indivisible) step. For non-zero values, the collector will perform\n          as if that amount of memory (in KBytes) had been allocated by Lua.\n          Returns true if the step finished a collection cycle.\n  "setpause": sets `arg` as the new value for the *pause* of the collector\n              (see §2.5). Returns the previous value for *pause*.\n  "setstepmul": sets `arg` as the new value for the *step multiplier*\n                of the collector (see §2.5). Returns the previous value for\n                *step*.\n  "isrunning": returns a boolean that tells whether the collector is running\n               (i.e., not stopped).
concat table.concat(list [, sep [, i [, j]]])\nGiven a list where all elements are strings or numbers, returns the string\n`list[i]..sep..list[i+1] ··· sep..list[j]`. The default value for `sep` is\nthe empty string, the default for `i` is 1, and the default for `j` is\n`#list`. If `i` is greater than `j`, returns the empty string.
config package.config (string)\nA string describing some compile-time configurations for packages. This\nstring is a sequence of lines:\n  The first line is the directory separator string. Default is '`\`' for\n  Windows and '`/`' for all other systems.\n  The second line is the character that separates templates in a path.\n  Default is '`;`'.\n  The third line is the string that marks the substitution points in a\n  template. Default is '`?`'.\n  The fourth line is a string that, in a path in Windows, is replaced by\n  the executable's directory. Default is '`!`'.\n  The fifth line is a mark to ignore all text after it when building the\n  `luaopen_` function name. Default is '`-`'.\n\nNew in Lua 5.2.
coroutine _G.coroutine (module)\nLua coroutine module.
cos math.cos(x)\nReturns the cosine of `x` (assumed to be in radians).
cosh math.cosh(x)\nReturns the hyperbolic cosine of `x`.\n\nDeprecated in Lua 5.3.
cpath package.cpath (string)\nThe path used by `require` to search for a C loader.\nLua initializes the C path `package.cpath` in the same way it initializes\nthe Lua path `package.path`, using the environment variable `LUA_CPATH_5_3`\nor the environment variable `LUA_CPATH` or a default path defined in\n`luaconf.h`.
create coroutine.create(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua\nfunction. Returns this new coroutine, an object with type `"thread"`.
css _G.snippets.css (table)\nContainer for CSS-specific snippets.
date os.date([format [, time]])\nReturns a string or a table containing date and time, formatted according\nto the given string `format`.\n\nIf the `time` argument is present, this is the time to be formatted\n(see the `os.time` function for a description of this value). Otherwise,\n`date` formats the current time.\n\nIf `format` starts with '`!`', then the date is formatted in Coordinated\nUniversal Time. After this optional character, if `format` is the string\n"`*t`", then `date` returns a table with the following fields: `year`,\n`month` (1-12), `day` (1-31), `hour` (0-23), `min` (0-59), `sec` (0-61),\n`wday` (weekday, Sunday is 1), `yday` (day of the year), and `isdst`\n(daylight saving flag, a boolean). This last field may be absent if the\ninformation is not available.\n\nIf `format` is not "`*t`", then `date` returns the date as a string,\nformatted according to the same rules as the ISO C function `strftime`.\n\nWhen called without arguments, `date` returns a reasonable date and time\nrepresentation that depends on the host system and on the current locale.\n(More specifically, `os.date()` is equivalent to `os.date("%c")`.)\n\nOn non-POSIX systems, this function may be not thread safe because of its\nreliance on C function `gmtime` and C function `localtime`.
debug _G.debug (module)\nLua debug module.
debug debug.debug()\nEnters an interactive mode with the user, running each string that\nthe user enters. Using simple commands and other debug facilities,\nthe user can inspect global and local variables, change their values,\nevaluate expressions, and so on. A line containing only the word `cont`\nfinishes this function, so that the caller continues its execution.\n\nNote that commands for `debug.debug` are not lexically nested within any\nfunction and so have no direct access to local variables.
deg math.deg(x)\nConverts the angle `x` from radians to degrees.
difftime os.difftime(t2, t1)\nReturns the difference, in seconds, from time `t1` to time `t2` (where the\ntimes are values returned by `os.time`). In POSIX, Windows, and some other\nsystems, this value is exactly `t2`*-*`t1`.
dofile _G.dofile([filename])\nOpens the named file and executes its contents as a Lua chunk. When\ncalled without arguments,\n`dofile` executes the contents of the standard input (`stdin`). Returns\nall values returned by the chunk. In case of errors, `dofile` propagates\nthe error to its caller (that is, `dofile` does not run in protected mode).
dump string.dump(function [, strip])\nReturns a string containing a binary representation (a _binary chunk_) of the\ngiven function, so that a later `load` on this string returns a copy of the\nfunction (but with new upvalues). If `strip` is a true value, the binary\nrepresentation is created without debug information about the function (local\nvariable names, lines, etc.).\n\nFunctions with upvalues have only their number of upvalues saved. When\n(re)loaded, those upvalues receive fresh instances containing nil. (You can\nuse the debug library to serialize and reload the upvalues of a function in a\nway adequate to your needs.)
encodings io.encodings (table)\nList of encodings to attempt to decode files as.\nYou should add to this list if you get a "Conversion failed" error when\ntrying to open a file whose encoding is not recognized. Valid encodings are\nGNU iconv's encodings and include:\n\n  * European: ASCII, ISO-8859-{1,2,3,4,5,7,9,10,13,14,15,16}, KOI8-R, KOI8-U,\n    KOI8-RU, CP{1250,1251,1252,1253,1254,1257}, CP{850,866,1131},\n    Mac{Roman,CentralEurope,Iceland,Croatian,Romania},\n    Mac{Cyrillic,Ukraine,Greek,Turkish}, Macintosh.\n  * Semitic: ISO-8859-{6,8}, CP{1255,1256}, CP862, Mac{Hebrew,Arabic}.\n  * Japanese: EUC-JP, SHIFT_JIS, CP932, ISO-2022-JP, ISO-2022-JP-2,\n    ISO-2022-JP-1.\n  * Chinese: EUC-CN, HZ, GBK, CP936, GB18030, EUC-TW, BIG5, CP950,\n    BIG5-HKSCS, BIG5-HKSCS:2004, BIG5-HKSCS:2001, BIG5-HKSCS:1999,\n    ISO-2022-CN, ISO-2022-CN-EXT.\n  * Korean: EUC-KR, CP949, ISO-2022-KR, JOHAB.\n  * Armenian: ARMSCII-8.\n  * Georgian: Georgian-Academy, Georgian-PS.\n  * Tajik: KOI8-T.\n  * Kazakh: PT154, RK1048.\n  * Thai: ISO-8859-11, TIS-620, CP874, MacThai.\n  * Laotian: MuleLao-1, CP1133.\n  * Vietnamese: VISCII, TCVN, CP1258.\n  * Unicode: UTF-8, UCS-2, UCS-2BE, UCS-2LE, UCS-4, UCS-4BE, UCS-4LE, UTF-16,\n    UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, UTF-7, C99, JAVA.
error _G.error(message [, level])\nTerminates the last protected function called and returns `message`\nas the error object. Function `error` never returns.\n\nUsually, `error` adds some information about the error position at the\nbeginning of the message, if the message is a string. The `level` argument\nspecifies how to get the error position. With level 1 (the default), the\nerror position is where the `error` function was called. Level 2 points the\nerror to where the function that called `error` was called; and so on.\nPassing a level 0 avoids the addition of error position information to the\nmessage.
events _G.events (module)\nTextadept's core event structure and handlers.
execute os.execute([command])\nThis function is equivalent to the ISO C function `system`. It passes\n`command` to be executed by an operating system shell. Its first result is\n`true` if the command terminated successfully, or `nil` otherwise. After this\nfirst result the function returns a string plus a number, as follows:\n  "exit": the command terminated normally; the following number is the exit\n          status of the command.\n  "signal": the command was terminated by a signal; the following number is\n            the signal that terminated the command.\n\nWhen called without a `command`, `os.execute` returns a boolean that is true\nif a shell is available.
exit os.exit([code [, close]])\nCalls the ISO C function `exit` to terminate the host program. If `code` is\n`true`, the returned status is `EXIT_SUCCESS`; if `code` is `false`, the\nreturned status is `EXIT_FAILURE`; if `code` is a number, the returned status\nis this number. The default value for `code` is `true`.\n\nIf the optional second argument `close` is true, closes the Lua state before\nexiting.
exp math.exp(x)\nReturns the value *e^x*.
extract bit32.extract(n, field [, width])\nReturns the unsigned number formed by the bits `field` to `field + width - 1`\nfrom `n`. Bits are numbered from 0 (least significant) to 31 (most\nsignificant). All accessed bits must be in the range [0, 31].\n\nThe default for `width` is 1.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
find string.find(s, pattern [, init [, plain]])\nLooks for the first match of `pattern` (see §6.4.1) in the string `s`. If it\nfinds a match, then `find` returns the indices of `s` where this occurrence\nstarts and ends; otherwise, it returns nil. A third, optional numerical\nargument `init` specifies where to start the search; its default value is 1\nand can be negative. A value of true as a fourth, optional argument `plain`\nturns off the pattern matching facilities, so the function does a plain\n"find substring" operation, with no characters in `pattern` being considered\nmagic. Note that if `plain` is given, then `init` must be given as well.\n\nIf the pattern has captures, then in a successful match the captured values\nare also returned, after the two indices.
floor math.floor(x)\nReturns the largest integral value smaller than or equal to `x`.
flush file:flush()\nSaves any written data to `file`.
flush io.flush()\nEquivalent to `io.output():flush()`.
fmod math.fmod(x, y)\nReturns the remainder of the division of `x` by `y` that rounds the\nquotient towards zero. (integer/float)
format string.format(formatstring, ···)\nReturns a formatted version of its variable number of arguments following the\ndescription given in its first argument (which must be a string). The format\nstring follows the same rules as the ISO C function `sprintf`. The only\ndifferences are that the options/modifiers `*`, `h`, `L`, `l`, `n`, and `p`\nare not supported and that there is an extra option, `q`. The `q` option\nformats a string between double quotes, using escape sequences when necessary\nto ensure that it can safely be read back by the Lua interpreter. For\ninstance, the call\n\n  string.format('%q', 'a string with "quotes" and \n new line')\n\nmay produce the string:\n\n  "a string with \"quotes\" and \\n      new line"\n\nOptions `A` and `a` (when available), `E`, `e`, `f`, `G`, and `g` all expect\na number as argument. Options `c`, `d`, `i`, `o`, `u`, `X`, and `x` expect an\ninteger. Option `q` expects a string. Option `s` expects a string; if its\nargument is not a string, it is converted to one following the same rules of\n`tostring`. If the option has any modifier (flags, width, length), the string\nargument should not contain zeros.
frexp math.frexp(x)\nReturns `m` and `e` such that 'x = m2^e', `e` is an integer and the\nabsolute value of `m` is in the range *[0.5, 1)* (or zero when `x` is zero).\n\nDeprecated in Lua 5.3.
get_project_root io.get_project_root(path)\nReturns the root directory of the project that contains filesystem path\n*path*.\nIn order to be recognized, projects must be under version control. Recognized\nVCSes are Bazaar, Git, Mercurial, SVN, and CVS.\n@param path Optional filesystem path to a project or a file contained within\n  a project. The default value is the buffer's filename or the current\n  working directory.\n@return string root or nil
getenv os.getenv(varname)\nReturns the value of the process environment variable `varname`, or\nnil if the variable is not defined.
getfenv _G.getfenv([f])\nReturns the current environment in use by the function. `f` can be a Lua\nfunction or a number that specifies the function at that stack level:\nLevel 1 is the function calling `getfenv`. If the given function is not a\nLua function, or if `f` is 0, `getfenv` returns the global environment. The\ndefault for `f` is 1.\n\nDeprecated in Lua 5.2.
getfenv debug.getfenv(o)\nReturns the environment of object `o`.\n\nDeprecated in Lua 5.2.
gethook debug.gethook([thread])\nReturns the current hook settings of the thread, as three values: the\ncurrent hook function, the current hook mask, and the current hook count\n(as set by the `debug.sethook` function).
getinfo debug.getinfo([thread, ] f [, what])\nReturns a table with information about a function. You can give the\nfunction directly or you can give a number as the value of `f`, which means\nthe function running at level `f` of the call stack of the given thread:\nlevel 0 is the current function (`getinfo` itself); level 1 is the function\nthat called `getinfo` and so on. If `f` is a number larger than the number of\nactive functions, then `getinfo` returns nil.\n\nThe returned table can contain all the fields returned by `lua_getinfo`,\nwith the string `what` describing which fields to fill in. The default for\n`what` is to get all information available, except the table of valid\nlines. If present, the option '`f`' adds a field named `func` with\nthe function itself. If present, the option '`L`' adds a field named\n`activelines` with the table of valid lines.\n\nFor instance, the expression `debug.getinfo(1,"n").name` returns a table\nwith a name for the current function, if a reasonable name can be found,\nand the expression `debug.getinfo(print)` returns a table with all available\ninformation about the `print` function.
getlocal debug.getlocal([thread, ] f, local)\nThis function returns the name and the value of the local variable with index\n`local` of the function at level `f` of the stack. This function accesses not\nonly explicit local variables, but also parameters, temporaries, etc.\n\nThe first parameter or local variable has index 1, and so on, following the\norder that they are declared in the code, counting only the variables that\nare active in the current scope of the function. Negative indices refer to\nvararg parameters; -1 is the first vararg parameter. The function returns nil\nif there is no variable with the given index, and raises an error when called\nwith a level out of range. (You can call `debug.getinfo` to check whether the\nlevel is valid.)\n\nVariable names starting with '(' (open parenthesis) represent variables with\nno known names (internal variables such as loop control variables, and\nvariables from chunks saved without debug information).\n\nThe parameter `f` may also be a function. In that case, `getlocal` returns\nonly the name of function parameters.
getmetatable _G.getmetatable(object)\nIf `object` does not have a metatable, returns nil. Otherwise, if the\nobject's metatable has a `"__metatable"` field, returns the associated\nvalue. Otherwise, returns the metatable of the given object.
getmetatable debug.getmetatable(value)\nReturns the metatable of the given `value` or nil if it does not have\na metatable.
getregistry debug.getregistry()\nReturns the registry table (see §4.5).
getupvalue debug.getupvalue(f, up)\nThis function returns the name and the value of the upvalue with index\n`up` of the function `f`. The function returns nil if there is no upvalue\nwith the given index.\n\nVariable names starting with '(' (open parenthesis) represent variables with\nno known names (variables from chunks saved without debug information).
getuservalue debug.getuservalue(u)\nReturns the Lua value associated to `u`. If `u` is not a userdata, returns\nnil.\n\nNew in Lua 5.2.
gmatch string.gmatch(s, pattern)\nReturns an iterator function that, each time it is called, returns the\nnext captures from `pattern` (see §6.4.1) over the string `s`. If `pattern`\nspecifies no captures, then the whole match is produced in each call.\n\nAs an example, the following loop will iterate over all the words from string\n`s`, printing one per line:\n\n  s = "hello world from Lua"\n  for w in string.gmatch(s, "%a+") do\n    print(w)\n  end\n\nThe next example collects all pairs `key=value` from the given string into a\ntable:\n\n  t = {}\n  s = "from=world, to=Lua"\n  for k, v in string.gmatch(s, "(%w+)=(%w+)") do\n    t[k] = v\n  end\n\nFor this function, a caret '`^`' at the start of a pattern does not work as\nan anchor, as this would prevent the iteration.
gsub string.gsub(s, pattern, repl [, n])\nReturns a copy of `s` in which all (or the first `n`, if given)\noccurrences of the `pattern` (see §6.4.1) have been replaced by a replacement\nstring specified by `repl`, which can be a string, a table, or a function.\n`gsub` also returns, as its second value, the total number of matches that\noccurred. The name `gsub` comes from "Global SUBstitution".\n\nIf `repl` is a string, then its value is used for replacement. The character\n`%` works as an escape character: any sequence in `repl` of the form `%d`,\nwith `d` between 1 and 9, stands for the value of the `d`-th captured\nsubstring. The sequence `%0` stands for the whole match. The sequence `%%`\nstands for a single `%`.\n\nIf `repl` is a table, then the table is queried for every match, using\nthe first capture as the key.\n\nIf `repl` is a function, then this function is called every time a match\noccurs, with all captured substrings passed as arguments, in order.\n\nIn any case, if the pattern specifies no captures, then it behaves as if the\nwhole pattern was inside a capture.\n\nIf the value returned by the table query or by the function call is a\nstring or a number, then it is used as the replacement string; otherwise,\nif it is false or nil, then there is no replacement (that is, the original\nmatch is kept in the string).\n\nHere are some examples:\n\n  x = string.gsub("hello world", "(%w+)", "%1 %1")\n  --> x="hello hello world world"\n  x = string.gsub("hello world", "%w+", "%0 %0", 1)\n  --> x="hello hello world"\n  x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")\n  --> x="world hello Lua from"\n  x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)\n  --> x="home = /home/roberto, user = roberto"\n  x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)\n        return load(s)()\n      end)\n  --> x="4+5 = 9"\n  local t = {name="lua", version="5.3"}\n  x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)\n  --> x="lua-5.3.tar.gz"
html _G.snippets.html (table)\nContainer for HTML-specific snippets.
huge math.huge (number)\nThe float value `HUGE_VAL`, a value larger than any other numerical value.
iconv string.iconv(text, new, old)\nConverts string *text* from encoding *old* to encoding *new* using iconv,\nreturning the string result.\nValid encodings are GNU iconv's encodings and include:\n\n  * European: ASCII, ISO-8859-{1,2,3,4,5,7,9,10,13,14,15,16}, KOI8-R, KOI8-U,\n    KOI8-RU, CP{1250,1251,1252,1253,1254,1257}, CP{850,866,1131},\n    Mac{Roman,CentralEurope,Iceland,Croatian,Romania},\n    Mac{Cyrillic,Ukraine,Greek,Turkish}, Macintosh.\n  * Semitic: ISO-8859-{6,8}, CP{1255,1256}, CP862, Mac{Hebrew,Arabic}.\n  * Japanese: EUC-JP, SHIFT_JIS, CP932, ISO-2022-JP, ISO-2022-JP-2,\n    ISO-2022-JP-1.\n  * Chinese: EUC-CN, HZ, GBK, CP936, GB18030, EUC-TW, BIG5, CP950,\n    BIG5-HKSCS, BIG5-HKSCS:2004, BIG5-HKSCS:2001, BIG5-HKSCS:1999,\n    ISO-2022-CN, ISO-2022-CN-EXT.\n  * Korean: EUC-KR, CP949, ISO-2022-KR, JOHAB.\n  * Armenian: ARMSCII-8.\n  * Georgian: Georgian-Academy, Georgian-PS.\n  * Tajik: KOI8-T.\n  * Kazakh: PT154, RK1048.\n  * Thai: ISO-8859-11, TIS-620, CP874, MacThai.\n  * Laotian: MuleLao-1, CP1133.\n  * Vietnamese: VISCII, TCVN, CP1258.\n  * Unicode: UTF-8, UCS-2, UCS-2BE, UCS-2LE, UCS-4, UCS-4BE, UCS-4LE, UTF-16,\n    UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, UTF-7, C99, JAVA.\n@param text The text to convert.\n@param new The string encoding to convert to.\n@param old The string encoding to convert from.
input io.input([file])\nWhen called with a file name, it opens the named file (in text mode),\nand sets its handle as the default input file. When called with a file\nhandle, it simply sets this file handle as the default input file. When\ncalled without parameters, it returns the current default input file.\n\nIn case of errors this function raises the error, instead of returning an\nerror code.
insert table.insert(list, [pos, ] value)\nInserts element `value` at position `pos` in `list`, shifting up the elements\n`list[pos], list[pos+1], ···, list[#list]`. The default value for `pos` is\n`#list+1`, so that a call `table.insert(t,x)` inserts `x` at the end of list\n`t`.
io _G.io (module)\nLua io module.
ipairs _G.ipairs(t)\nReturns three values (an iterator function, the table `t`, and 0) so that the\nconstruction\n\n  for i,v in ipairs(t) do *body* end\n\nwill iterate over the key-value pairs (`1,t[1]`), (`2,t[2]`), ···, up to the\nfirst nil value.
isyieldable coroutine.isyieldable()\nReturns true when the running coroutine can yield.\n\nA running coroutine is yieldable if it is not the main thread and it is not\ninside a non-yieldable C function.\n\nNew in Lua 5.3.
kill spawn_proc:kill(signal)\nKills running process *spawn_proc*, or sends it Unix signal *signal*.\n@param signal Optional Unix signal to send to *spawn_proc*. The default value\n  is 9 (`SIGKILL`), which kills the process.
ldexp math.ldexp(m, e)\nReturns 'm2^e' (`e` should be an integer).\n\nDeprecated in Lua 5.3.
len string.len(s)\nReceives a string and returns its length. The empty string `""` has\nlength 0. Embedded zeros are counted, so `"a\000bc\000"` has length 5.
len utf8.len(s [, i [, j]])\nReturns the number of UTF-8 characters in string `s` that start between\npositions `i` and `j` (both inclusive). The default for `i` is 1 and for `j`\nis -1. If it finds any invalid byte sequence, returns a false value plus the\nposition of the first invalid byte.\n\nNew in Lua 5.3.
lexer _G.lexer (module)\nLexes Scintilla documents with Lua and LPeg.
lines file:lines(···)\nReturns an iterator function that, each time it is called, reads the file\naccording to the given formats. When no format is given, uses "l" as a\ndefault. As an example, the construction\n\n  for c in file:lines(1) do *body* end\n\nwill iterate over all characters of the file, starting at the current\nposition. Unlike `io.lines`, this function does not close the file when the\nloop ends.\n\nIn case of errors this function raises the error, instead of returning an\nerror code.
lines io.lines([filename, ···])\nOpens the given file name in read mode and returns an iterator function that\nworks like `file:lines(···)` over the opened file. When the iterator function\ndetects -- the end of file, it returns no values (to finish the loop) and\nautomatically closes the file.\n\nThe call `io.lines()` (with no file name) is equivalent to\n`io.input():lines("l")`; that is, it iterates over the lines of the default\ninput file. In this case it does not close the file when the loop ends.\n\nIn case of errors this function raises the error, instead of returning an\nerror code.
load _G.load(chunk [, chunkname [, mode [, env]]])\nLoads a chunk.\n\nIf `chunk` is a string, the chunk is this string. If `chunk` is a function, `load`\ncalls it repeatedly to get the chunk pieces. Each call to `chunk` must return a\nstring that concatenates with previous results. A return of an empty string,\nnil, or no value signals the end of the chunk.\n\nIf there are no syntactic errors, returns the compiled chunk as a function;\notherwise, returns nil plus the error message.\n\nIf the resulting function has upvalues, the first upvalue is set to the value\nof `env`, if that parameter is given, or to the value of the global\nenvironment. Other upvalues are initialized with nil. (When you load a main\nchunk, the resulting function will always have exactly one upvalue, the\n`_ENV` variable (see §2.2). However, when you load a binary chunk created\nfrom a function (see `string.dump`), the resulting function can have an\narbitrary number of upvalues.) All upvalues are fresh, that is, they are not\nshared with any other function.\n\n`chunkname` is used as the name of the chunk for error messages and debug\ninformation (see §4.9). When absent, it defaults to `chunk`, if `chunk` is a\nstring, or to "`=(load)`" otherwise.\n\nThe string `mode` controls whether the chunk can be text or binary (that is,\na precompiled chunk). It may be the string "`b`" (only binary chunks), "`t`"\n(only text chunks), or "`bt`" (both binary and text). The default is "`bt`".\n\nLua does not check the consistency of binary chunks. Maliciously crafted\nbinary chunks can crash the interpreter.
loaded package.loaded (table)\nA table used by `require` to control which modules are already loaded. When\nyou require a module `modname` and `package.loaded[modname]` is not false,\n`require` simply returns the value stored there.\nThis variable is only a reference to the real table; assignments to this\nvariable do not change the table used by `require`.
loaders package.loaders (table)\nSee `package.searchers`.\n\nDeprecated in Lua 5.2.
loadfile _G.loadfile([filename [, mode [, env]]])\nSimilar to `load`, but gets the chunk from file `filename` or from the\nstandard input, if no file name is given.
loadlib package.loadlib(libname, funcname)\nDynamically links the host program with the C library `libname`.\n\nIf `funcname` is "`*`", then it only links with the library, making the\nsymbols exported by the library available to other dynamically linked\nlibraries. Otherwise, it looks for a function `funcname` inside the library\nand returns this function as a C function. So, `funcname` must follow the\n`lua_CFunction` prototype (see `lua_CFunction`).\n\nThis is a low-level function. It completely bypasses the package and module\nsystem. Unlike `require`, it does not perform any path searching and does\nnot automatically adds extensions. `libname` must be the complete file name\nof the C library, including if necessary a path and an extension. `funcname`\nmust be the exact name exported by the C library (which may depend on the\nC compiler and linker used).\n\nThis function is not supported by Standard C. As such, it is only available\non some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix\nsystems that support the `dlfcn` standard).
loadstring _G.loadstring(string [, chunkname])\nSimilar to `load`, but gets the chunk from the given string. To load and\nrun a given string, use the idiom assert(loadstring(s))() When absent,\n`chunkname` defaults to the given string.\n\nDeprecated in Lua 5.2.
log math.log(x [, base])\nReturns the logarithm of `x` in the given base. The default for `base` is 'e'\n(so that the function returns the natural logarithm of `x`).
log10 math.log10(x)\nReturns the base-10 logarithm of `x`.\n\nDeprecated in Lua 5.2.
lower string.lower(s)\nReceives a string and returns a copy of this string with all uppercase\nletters changed to lowercase. All other characters are left unchanged. The\ndefinition of what an uppercase letter is depends on the current locale.
lrotate bit32.lrotate(x, disp)\nReturns the number `x` rotated `disp` bits to the left. The number `disp` may\nbe any representable integer.\n\nFor any valid displacement, the following identity holds:\n\n  assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))\n\nIn particular, negative displacements rotate to the right.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
lshift bit32.lshift(x, disp)\nReturns the number `x` shifted `disp` bits to the left. The number `disp` may\nbe any representable integer. Negative displacements shift to the right. In\nany direction, vacant bits are filled with zeros. In particular,\ndisplacements with absolute values higher than 31 result in zero (all bits\nare shifted out).\n\nFor positive displacements, the following equality holds:\n\n  assert(bit32.lshift(b, disp) == (b * 2^disp) % 2^32)\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
lua _G.snippets.lua (table)\nContainer for Lua-specific snippets.
match string.match(s, pattern [, init])\nLooks for the first *match* of `pattern` (see §6.4.1) in the string `s`. If\nit finds one, then `match` returns the captures from the pattern; otherwise\nit returns nil. If `pattern` specifies no captures, then the whole match\nis returned. A third, optional numerical argument `init` specifies where\nto start the search; its default value is 1 and can be negative.
math _G.math (module)\nLua math module.
max math.max(x, ···)\nReturns the argument with the maximum value, according to the Lua operator\n`<`. (integer/float)
maxinteger math.maxinteger (number)\nAn integer with the maximum value for an integer.\n\nNew in Lua 5.3.
maxn table.maxn(table)\nReturns the largest positive numerical index of the given table, or zero if\nthe table has no positive numerical indices. (To do its job this function\ndoes a linear traversal of the whole table.)\n\nDeprecated in Lua 5.2.
min math.min(x, ···)\nReturns the argument with the minimum value, according to the Lua operator\n`<`. (integer/float)
mininteger math.mininteger (number)\nAn integer with the minimum value for an integer.\n\nNew in Lua 5.3.
modf math.modf(x)\nReturns the integral part of `x` and the fractional part of `x`. Its second\nresult is always a float.
move table.move(a1, f, e, t [, a2])\nMoves elements from table `a1` to table `a2`. This function performs the\nequivalent to the following multiple assignment: `a2[t], ··· = a1[f], ···,\na1[e]`. The default for `a2` is `a1`. The destination range can overlap with\nthe source range. Index `f` must be positive.\n\nNew in Lua 5.3.
next _G.next(table [, index])\nAllows a program to traverse all fields of a table. Its first argument is\na table and its second argument is an index in this table. `next` returns\nthe next index of the table and its associated value. When called with nil\nas its second argument, `next` returns an initial index and its associated\nvalue. When called with the last index, or with nil in an empty table, `next`\nreturns nil. If the second argument is absent, then it is interpreted as\nnil. In particular, you can use `next(t)` to check whether a table is empty.\n\nThe order in which the indices are enumerated is not specified, *even for\nnumeric indices*. (To traverse a table in numeric order, use a numerical\n`for`.)\n\nThe behavior of `next` is undefined if, during the traversal, you assign any\nvalue to a non-existent field in the table. You may however modify existing\nfields. In particular, you may clear existing fields.
offset utf8.offset(s, n [, i])\nReturns the position (in bytes) where the encoding of the `n`-th character of\n`s` (counting from position `i`) starts. A negative `n` gets characters\nbefore position `i`. The default for `i` is 1 when `n` is non-negative and\n`#s + 1` otherwise, so that `utf8.offset(s, -n)` gets the offset of the\n`n`-th character from the end of the string. If the specified character is\nneither in the subject nor right after its end, the function returns nil.\n\nAs a special case, when `n` is 0 the function returns the start of the\nencoding of the character that contains the `i`-th byte of `s`.\n\nThis function assumes that `s` is a valid UTF-8 string.\n\nNew in Lua 5.3.
open io.open(filename [, mode])\nThis function opens a file, in the mode specified in the string `mode`. It\nreturns a new file handle, or, in case of errors, nil plus an error message.\n\nThe `mode` string can be any of the following:\n  "r": read mode (the default);\n  "w": write mode;\n  "a": append mode;\n  "r+": update mode, all previous data is preserved;\n  "w+": update mode, all previous data is erased;\n  "a+": append update mode, previous data is preserved, writing is only\n        allowed at the end of file.\n\nThe `mode` string can also have a '`b`' at the end, which is needed in\nsome systems to open the file in binary mode.
open_file io.open_file(filenames)\nOpens *filenames*, a string filename or list of filenames, or the\nuser-selected filenames.\nEmits a `FILE_OPENED` event.\n@param filenames Optional string filename or table of filenames to open. If\n  `nil`, the user is prompted with a fileselect dialog.\n@see _G.events
open_recent_file io.open_recent_file()\nPrompts the user to select a recently opened file to be reopened.\n@see recent_files
os _G.os (module)\nLua os module.
output io.output([file])\nSimilar to `io.input`, but operates over the default output file.
pack string.pack(fmt, v1, v2, ···)\nReturns a binary string containing the values `v1`, `v2`, etc. packed (that\nis, serialized in binary form) according to the format string `fmt` (see\n§6.4.2).\n\nNew in Lua 5.3.
package _G.package (module)\nLua package module.
packsize string.packsize(fmt)\nReturns the size of a string resulting from `string.pack` with the given\nformat. The format string cannot have the variable-length options 's' or 'z'\n(see §6.4.2).\n\nNew in Lua 5.3.
pairs _G.pairs(t)\nIf `t` has a metamethod `__pairs`, calls it with `t` as argument and returns\nthe first three results from the call.\n\nOtherwise, returns three values: the `next` function, the table `t`, and nil,\nso that the construction\n\n  for k,v in pairs(t) do *body* end\n\nwill iterate over all key–value pairs of table `t`.\n\nSee function `next` for the caveats of modifying the table during its\ntraversal.
path package.path (string)\nThe path used by `require` to search for a Lua loader.\nAt start-up, Lua initializes this variable with the value of the\nenvironment variable `LUA_PATH_5_3` or the environment variable `LUA_PATH`\nor with a default path defined in `luaconf.h`, if those environment\nvariables are not defined. Any "`;;`" in the value of the environment\nvariable is replaced by the default path.
pcall _G.pcall(f [, arg1, ···])\nCalls function `f` with the given arguments in *protected mode*. This\nmeans that any error inside `f` is not propagated; instead, `pcall` catches\nthe error and returns a status code. Its first result is the status code (a\nboolean), which is true if the call succeeds without errors. In such case,\n`pcall` also returns all results from the call, after this first result. In\ncase of any error, `pcall` returns false plus the error message.
pi math.pi (number)\nThe value of 'π'.
popen io.popen(prog [, mode])\nStarts program `prog` in a separated process and returns a file handle\nthat you can use to read data from this program (if `mode` is `"r"`,\nthe default) or to write data to this program (if `mode` is `"w"`).\n\nThis function is system dependent and is not available on all platforms.
pow math.pow(x, y)\nReturns *x^y*. (You can also use the expression `x^y` to compute this\nvalue.)\n\nDeprecated in Lua 5.3.
preload package.preload (table)\nA table to store loaders for specific modules (see `require`).\nThis variable is only a reference to the real table; assignments to this\nvariable do not change the table used by `require`.
print _G.print(···)\nReceives any number of arguments and prints their values to `stdout`, using\nthe `tostring` function to convert each argument to a string. `print` is not\nintended for formatted output, but only as a quick way to show a value,\nfor instance for debugging. For complete control over the output, use\n`string.format` and `io.write`.
python _G.snippets.python (table)\nContainer for Python-specific snippets.
rad math.rad(x)\nConverts the angle `x` from degrees to radians.
random math.random([m [, n]])\nWhen called without arguments, returns a pseudo-random float with uniform\ndistribution in the range [0,1). When called with two integers `m` and `n`,\n`math.random` returns a pseudo-random integer with uniform distribution in\nthe range `[m, n]. (The value `n-m` cannot be negative and must fit in a Lua\ninteger.) The call `math.random(n)` is equivalent to `math.random(1, n)`.\n\nThis function is an interface to the underling pseudo-random generator\nfunction provided by C.
randomseed math.randomseed(x)\nSets `x` as the "seed" for the pseudo-random generator: equal seeds\nproduce equal sequences of numbers.
rawequal _G.rawequal(v1, v2)\nChecks whether `v1` is equal to `v2`, without invoking any\nmetamethod. Returns a boolean.
rawget _G.rawget(table, index)\nGets the real value of `table[index]`, without invoking any\nmetamethod. `table` must be a table; `index` may be any value.
rawlen _G.rawlen(v)\nReturns the length of the object `v`,\nwhich must be a table or a string,\nwithout invoking any metamethod.\nReturns an integer.\n\nNew in Lua 5.2.
rawset _G.rawset(table, index, value)\nSets the real value of `table[index]` to `value`, without invoking any\nmetamethod. `table` must be a table, `index` any value different from nil and\nNaN, and `value` any Lua value.\n\nThis function returns `table`.
read file:read(···)\nReads the file `file`, according to the given formats, which specify\nwhat to read. For each format, the function returns a string or a number\nwith the characters read, or nil if it cannot read data with the specified\nformat. (In this latter case, the function does not read subsequent formats.)\nWhen called without formats, it uses a default format that reads the next\nline (see below).\n\nThe available formats are\n  "n": reads a numeral and returns it as a float or an integer, following the\n       lexical conventions of Lua. (The numeral may have leading spaces and a\n       sign.) This format always reads the longest input sequence that is a\n       valid prefix for a number; if that prefix does not form a valid number\n       (e.g., an empty string, "0x", or "3.4e-"), it is discarded and the\n       function returns nil.\n  "a": reads the whole file, starting at the current position. On end of\n       file, it returns the empty string.\n  "l": reads the next line skipping the end of line, returning nil on\n       end of file. This is the default format.\n  "L": reads the next line keeping the end-of-line character (if present),\n       returning nil on end of file.\n  *number*: reads a string with up to this number of bytes, returning nil on\n       end of file. If *number* is zero, it reads nothing and returns an\n       empty string, or nil on end of file.\n\nThe formats "l" and "L" should be used only for text files.
read io.read(···)\nEquivalent to `io.input():read(···)`.
read spawn_proc:read(arg)\nReads and returns stdout from process *spawn_proc*, according to string\nformat or number *arg*.\nSimilar to Lua's `io.read()` and blocks for input. *spawn_proc* must still be\nrunning. If an error occurs while reading, returns `nil`, an error code, and\nan error message.\nEnsure any read operations read all stdout available. The stdout callback\nfunction passed to `spawn()` will not be called until the stdout buffer is\nclear.\n@param arg Optional argument similar to those in Lua's `io.read()`, but "n"\n  is not supported. The default value is "l", which reads a line.\n@return string of bytes read
recent_files io.recent_files (table)\nList of recently opened files, the most recent being towards the top.
register args.register(short, long, narg, f, description)\nRegisters a command line switch with short and long versions *short* and\n*long*, respectively. *narg* is the number of arguments the switch accepts,\n*f* is the function called when the switch is tripped, and *description* is\nthe switch's description when displaying help.\n@param short The string short version of the switch.\n@param long The string long version of the switch.\n@param narg The number of expected parameters for the switch.\n@param f The Lua function to run when the switch is tripped.\n@param description The string description of the switch for command line\n  help.
reload_file io.reload_file()\nReloads the current buffer's file contents, discarding any changes.
remove os.remove(filename)\nDeletes the file (or empty directory, on POSIX systems) with the given name.\nIf this function fails, it returns nil, plus a string describing the error\nand the error code.
remove table.remove(list [, pos])\nRemoves from `list` the element at position `pos`, returning the value of the\nremoved element. When `pos` is an integer between 1 and `#list`, it shifts\ndown the elements `list[pos+1], list[pos+2], ···, list[#list]` and erases\nelement `list[#list]`; The index `pos` can also be 0 when `#list` is 0, or\n`#list + 1`; in those cases, the function erases the element `list[pos]`.\n\nThe default value for `pos` is `#list`, so that a call `table.remove(l)`\nremoves the last element of list `l`.
rename os.rename(oldname, newname)\nRenames file or directory named `oldname` to `newname`. If this function\nfails, it returns nil, plus a string describing the error and the error code.
rep string.rep(s, n [, sep])\nReturns a string that is the concatenation of `n` copies of the string `s`\nseparated by the string `sep`. The default value for `sep` is the empty\nstring (that is, no separator). Returns the empty string if `n` is not\npositive.\n\n(Note that it is very easy to exhaust the memory of your machine with a\nsingle call to this function.)
replace bit32.replace(n, v, field [, width])\nReturns a copy of `n` with the bits `field` to `field + width - 1` replaced\nby the value `v`. See `bit32.extract` for details about `field` and `width`.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
require _G.require(modname)\nLoads the given module. The function starts by looking into the\n`package.loaded` table to determine whether `modname` is already\nloaded. If it is, then `require` returns the value stored at\n`package.loaded[modname]`. Otherwise, it tries to find a *loader* for\nthe module.\n\nTo find a loader, `require` is guided by the `package.searchers` sequence. By\nchanging this sequence, we can change how `require` looks for a module. The\nfollowing explanation is based on the default configuration for\n`package.searchers`.\n\nFirst `require` queries `package.preload[modname]`. If it has a value,\nthis value (which must be a function) is the loader. Otherwise `require`\nsearches for a Lua loader using the path stored in `package.path`. If\nthat also fails, it searches for a C loader using the path stored in\n`package.cpath`. If that also fails, it tries an *all-in-one* loader (see\n`package.searchers`).\n\nOnce a loader is found, `require` calls the loader with two arguments:\n`modname` and an extra value dependent on how it got the loader. (If the\nloader came from a file, this extra value is the file name.) If the loader\nreturns any non-nil value, `require` assigns the returned value to\n`package.loaded[modname]`. If the loader does not return a non-nil value and\nhas not assigned any value to `package.loaded[modname]`, then `require`\nassigns true to this entry. In any case, `require` returns the final value of\n`package.loaded[modname]`.\n\nIf there is any error loading or running the module, or if it cannot find\nany loader for the module, then `require` raises an error.
rest _G.snippets.rest (table)\nContainer for reST-specific snippets.
resume coroutine.resume(co [, val1, ···])\nStarts or continues the execution of coroutine `co`. The first time\nyou resume a coroutine, it starts running its body. The values `val1`,\n··· are passed as the arguments to the body function. If the coroutine\nhas yielded, `resume` restarts it; the values `val1`, ··· are passed\nas the results from the yield.\n\nIf the coroutine runs without any errors, `resume` returns true plus any\nvalues passed to `yield` (when the coroutine yields) or any values returned\nby the body function (when the coroutine terminates). If there is any error,\n`resume` returns false plus the error message.
reverse string.reverse(s)\nReturns a string that is the string `s` reversed.
rrotate bit32.rrotate(x, disp)\nReturns the number `x` rotated `disp` bits to the right. The number `disp`\nmay be any representable integer.\n\nFor any valid displacement, the following identity holds:\n\n  assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))\n\nIn particular, negative displacements rotate to the left.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
rshift bit32.rshift(x, disp)\nReturns the number `x` shifted `disp` bits to the right. The number `disp`\nmay be any representable integer. Negative displacements shift to the left.\nIn any direction, vacant bits are filled with zeros. In particular,\ndisplacements with absolute values higher than 31 result in zero (all bits\nare shifted out).\n\nFor positive displacements, the following equality holds:\n\n  assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))\n\nThis shift operation is what is called logical shift.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
ruby _G.snippets.ruby (table)\nContainer for Ruby-specific snippets.
running coroutine.running()\nReturns the running coroutine plus a boolean, true when the running coroutine\nis the main one.
save_all_files io.save_all_files()\nSaves all unsaved buffers to their respective files.\n@see io.save_file
save_file_as io.save_file_as(filename)\nSaves the current buffer to file *filename* or the user-specified filename.\nEmits a `FILE_AFTER_SAVE` event.\n@param filename Optional new filepath to save the buffer to. If `nil`, the\n  user is prompted for one.
searchers package.searchers (table)\nA table used by `require` to control how to load modules.\nEach entry in this table is a *searcher function*. When looking for a\nmodule, `require` calls each of these searchers in ascending order, with\nthe module name (the argument given to `require`) as its sole parameter.\nThe function can return another function (the module *loader*) plus an\nextra value that will be passed to that loader, or a string explaining why\nit did not find that module (or nil if it has nothing to say).\nLua initializes this table with four functions.\nThe first searcher simply looks for a loader in the `package.preload`\ntable.\nThe second searcher looks for a loader as a Lua library, using the path\nstored at `package.path`. The search is done as described in function\n`package.searchpath`.\nThe third searcher looks for a loader as a C library, using the path given\nby the variable `package.cpath`. Again, the search is done as described in\nfunction `package.searchpath`. For instance, if the C path is the string\n  "./?.so;./?.dll;/usr/local/?/init.so"\nthe searcher for module `foo` will try to open the files `./foo.so`,\n`./foo.dll`, and `/usr/local/foo/init.so`, in that order. Once it finds\na C library, this searcher first uses a dynamic link facility to link the\napplication with the library. Then it tries to find a C function inside the\nlibrary to be used as the loader. The name of this C function is the string\n"`luaopen_`" concatenated with a copy of the module name where each dot\nis replaced by an underscore. Moreover, if the module name has a hyphen,\nits suffix after (and including) the first hyphen is removed. For instance,\nif the module name is `a.b.c-v2.1 `, the function name will be\n`luaopen_a_b_c`. The fourth searcher tries an *all-in-one loader*. It\nsearches the C path for a library for the root name of the given module.\nFor instance, when requiring `a.b.c`, it will search for a C library for\n`a`. If found, it looks into it for an open function for the submodule; in\nour example, that would be `luaopen_a_b_c`. With this facility, a package\ncan pack several C submodules into one single library, with each submodule\nkeeping its original open function.\nAll searchers except the first one (preload) return as the extra value the\nfile name where the module was found, as returned by `package.searchpath`.\nThe first searcher returns no extra value.\n\nNew in Lua 5.2.
searchpath package.searchpath(name, path [, sep [, rep]])\nSearches for the given `name` in the given `path`.\n\nA path is a string containing a sequence of _templates_ separated by\nsemicolons. For each template, the function replaces each interrogation mark\n(if any) in the template with a copy of `name` wherein all occurrences of\n`sep` (a dot, by default) were replaced by `rep` (the system's directory\nseparator, by default), and then tries to open the resulting file name.\nFor instance, if the path is the string\n  "./?.lua;./?.lc;/usr/local/?/init.lua"\nthe search for the name `foo.a` will try to open the files `./foo/a.lua`,\n`./foo/a.lc`, and `/usr/local/foo/a/init.lua`, in that order.\nReturns the resulting name of the first file that it can open in read mode\n(after closing the file), or nil plus an error message if none succeeds.\n(This error message lists all file names it tried to open.)\n\nNew in Lua 5.2.
seeall package.seeall(module)\nSets a metatable for `module` with its `__index` field referring to the\nglobal environment, so that this module inherits values from the global\nenvironment. To be used as an option to function `module`.\n\nDeprecated in Lua 5.2.
seek file:seek([whence [, offset]])\nSets and gets the file position, measured from the beginning of the\nfile, to the position given by `offset` plus a base specified by the string\n`whence`, as follows:\n  "set": base is position 0 (beginning of the file);\n  "cur": base is current position;\n  "end": base is end of file;\n\nIn case of success, function `seek` returns the final file position,\nmeasured in bytes from the beginning of the file. If `seek` fails, it returns\nnil, plus a string describing the error.\n\nThe default value for `whence` is `"cur"`, and for `offset` is 0. Therefore,\nthe call `file:seek()` returns the current file position, without changing\nit; the call `file:seek("set")` sets the position to the beginning of the\nfile (and returns 0); and the call `file:seek("end")` sets the position\nto the end of the file, and returns its size.
select _G.select(index, ···)\nIf `index` is a number, returns all arguments after argument number\n`index`; a negative number indexes from the end (-1 is the last argument).\nOtherwise, `index` must be the string `"#"`, and `select` returns the total\nnumber of extra arguments it received.
setfenv _G.setfenv(f, table)\nSets the environment to be used by the given function. `f` can be a Lua\nfunction or a number that specifies the function at that stack level: Level 1\nis the function calling `setfenv`. `setfenv` returns the given function. As a\nspecial case, when `f` is 0 `setfenv` changes the environment of the running\nthread. In this case, `setfenv` returns no values.\n\nDeprecated in Lua 5.2.
setfenv debug.setfenv(object, table)\nSets the environment of the given `object` to the given `table`. Returns\n`object`.\n\nDeprecated in Lua 5.2.
sethook debug.sethook([thread, ] hook, mask [, count])\nSets the given function as a hook. The string `mask` and the number\n`count` describe when the hook will be called. The string mask may have any\ncombination of the following characters, with the given meaning:\n  "c": the hook is called every time Lua calls a function;\n  "r": the hook is called every time Lua returns from a function;\n  "l": the hook is called every time Lua enters a new line of code.\n\nMoreover, with a `count` different from zero, the hook is called also after\nevery `count` instructions.\n\nWhen called without arguments, `debug.sethook` turns off the hook.\n\nWhen the hook is called, its first parameter is a string describing\nthe event that has triggered its call: `"call"` (or `"tail call"`),\n`"return"`, `"line"`, and `"count"`. For line events, the hook also gets the\nnew line number as its second parameter. Inside a hook, you can call\n`getinfo` with level 2 to get more information about the running function\n(level 0 is the `getinfo` function, and level 1 is the hook function).
setlocal debug.setlocal([thread, ] level, local, value)\nThis function assigns the value `value` to the local variable with\nindex `local` of the function at level `level` of the stack. The function\nreturns nil if there is no local variable with the given index, and raises\nan error when called with a `level` out of range. (You can call `getinfo`\nto check whether the level is valid.) Otherwise, it returns the name of\nthe local variable.\n\nSee `debug.getlocal` for more information about variable indices and names.
setlocale os.setlocale(locale [, category])\nSets the current locale of the program. `locale` is a system-dependent string\nspecifying a locale; `category` is an optional string describing which\ncategory to change: `"all"`, `"collate"`, `"ctype"`, `"monetary"`,\n`"numeric"`, or `"time"`; the default category is `"all"`. The function\nreturns the name of the new locale, or nil if the request cannot be honored.\n\nIf `locale` is the empty string, the current locale is set to an\nimplementation-defined native locale. If `locale` is the string "`C`",\nthe current locale is set to the standard C locale.\n\nWhen called with nil as the first argument, this function only returns\nthe name of the current locale for the given category.\n\nThis function may not be thread safe because of its reliance on C function\n`setlocale`.
setmetatable _G.setmetatable(table, metatable)\nSets the metatable for the given table. (To change the metatable of other\ntypes from Lua code, you must use the debug library.) If `metatable` is nil,\nremoves the metatable of the given table. If the original metatable has a\n`"__metatable"` field, raises an error.\n\nThis function returns `table`.
setmetatable debug.setmetatable(value, table)\nSets the metatable for the given `value` to the given `table` (which\ncan be nil).
setupvalue debug.setupvalue(f, up, value)\nThis function assigns the value `value` to the upvalue with index `up`\nof the function `f`. The function returns nil if there is no upvalue with the\ngiven index. Otherwise, it returns the name of the upvalue.
setuservalue debug.setuservalue(udata, value)\nSets the given `value` as the Lua value associated to the given `udata`.\n`udata` must be a full userdata.\n\nReturns `udata`.\n\nNew in Lua 5.2.
setvbuf file:setvbuf(mode [, size])\nSets the buffering mode for an output file. There are three available\nmodes:\n  "no": no buffering; the result of any output operation appears immediately.\n  "full": full buffering; output operation is performed only when the\n          buffer is full or when you explicitly `flush` the file (see\n          `io.flush`).\n  "line": line buffering; output is buffered until a newline is output or\n          there is any input from some special files (such as a terminal\n          device).\n\nFor the last two cases, `size` specifies the size of the buffer, in\nbytes. The default is an appropriate size.
sin math.sin(x)\nReturns the sine of `x` (assumed to be in radians).
sinh math.sinh(x)\nReturns the hyperbolic sine of `x`.\n\nDeprecated in Lua 5.3.
size view.size (number)\nThe split resizer's pixel position if the view is a split one.
snapopen_filters io.snapopen_filters (table)\nMap of file paths to filters used by `io.snapopen()`.\n@see snapopen
sort table.sort(list [, comp])\nSorts list elements in a given order, *in-place*, from `list[1]` to\n`list[#list]`. If `comp` is given, then it must be a function that receives\ntwo list elements and returns true when the first element must come before\nthe second in the final order (so that, after the sort, `i < j` implies\n`not comp(list[j],list[i])` will be true after the sort). If `comp` is not\ngiven, then the standard Lua operator `<` is used instead.\n\nNote that the `comp` function must not define a string partial order over the\nelements in the list; that is, it must be asymmetric and transitive.\nOtherwise, no valid sort may be possible.\n\nThe sort algorithm is not stable; that is, elements not comparable by the\ngiven order (e.g., equal elements) may have their relative positions changed\nby the sort.
sqrt math.sqrt(x)\nReturns the square root of `x`. (You can also use the expression `x^0.5`\nto compute this value.)
status coroutine.status(co)\nReturns the status of coroutine `co`, as a string: `"running"`, if\nthe coroutine is running (that is, it called `status`); `"suspended"`, if\nthe coroutine is suspended in a call to `yield`, or if it has not started\nrunning yet; `"normal"` if the coroutine is active but not running (that\nis, it has resumed another coroutine); and `"dead"` if the coroutine has\nfinished its body function, or if it has stopped with an error.
status spawn_proc:status()\nReturns the status of process *spawn_proc*, which is either "running" or\n"terminated".\n@return "running" or "terminated"
stderr io.stderr (file)\nStandard error.
stdin io.stdin (file)\nStandard in.
stdout io.stdout (file)\nStandard out.
string _G.string (module)\nLua string module.
sub string.sub(s, i [, j])\nReturns the substring of `s` that starts at `i` and continues until\n`j`; `i` and `j` can be negative. If `j` is absent, then it is assumed to\nbe equal to -1 (which is the same as the string length). In particular,\nthe call `string.sub(s,1,j)` returns a prefix of `s` with length `j`, and\n`string.sub(s, -i)` returns a suffix of `s` with length `i`.\n\nIf, after the translation of negative indices, `i` is less than 1, it is\ncorrected to 1. If `j` is greater than the string length, it is corrected to\nthat length. If, after these corrections, `i` is greater than `j`, the\nfunction returns the empty string.
table _G.table (module)\nLua table module.
tan math.tan(x)\nReturns the tangent of `x` (assumed to be in radians).
tanh math.tanh(x)\nReturns the hyperbolic tangent of `x`.\n\nDeprecated in Lua 5.3.
time os.time([table])\nReturns the current time when called without arguments, or a time\nrepresenting the date and time specified by the given table. This table\nmust have fields `year`, `month`, and `day`, and may have fields `hour`\n(default is 12), `min` (default is 0), `sec` (default is 0), and `isdst`\n(default is nil). For a description of these fields, see the `os.date`\nfunction.\n\nThe returned value is a number, whose meaning depends on your system. In\nPOSIX, Windows, and some other systems, this number counts the number of\nseconds since some given start time (the "epoch"). In other systems, the\nmeaning is not specified, and the number returned by `time` can be used only\nas an argument to `os.date` and `os.difftime`.
timeout _G.timeout(interval, f, ...)\nCalls function *f* with the given arguments after *interval* seconds.\nIf *f* returns `true`, calls *f* repeatedly every *interval* seconds as long\nas *f* returns `true`. A `nil` or `false` return value stops repetition.\n@param interval The interval in seconds to call *f* after.\n@param f The function to call.\n@param ... Additional arguments to pass to *f*.
tmpfile io.tmpfile()\nReturns a handle for a temporary file. This file is opened in update\nmode and it is automatically removed when the program ends.
tmpname os.tmpname()\nReturns a string with a file name that can be used for a temporary\nfile. The file must be explicitly opened before its use and explicitly\nremoved when no longer needed.\n\nOn POSIX systems, this function also creates a file with that name, to avoid\nsecurity risks. (Someone else might create the file with wrong permissions in\nthe time between getting the name and creating the file.) You still have to\nopen the file to use it and to remove it (even if you do not use it).\n\nWhen possible, you may prefer to use `io.tmpfile`, which automatically\nremoves the file when the program ends.
tointeger math.tointeger(x)\nIf the value `x` is convertible to an integer, returns that integer.\nOtherwise, returns nil.\n\nNew in Lua 5.3.
tonumber _G.tonumber(e [, base])\nWhen called with no `base`, `tonumber` tries to convert its argument to a\nnumber. If the argument is already a number or a string convertible to a\nnumber, then `tonumber` returns this number; otherwise, it\nreturns nil.\n\nThe conversion of strings can result in integers or floats, according to the\nlexical conventions of Lua (see §3.1). (The string may have leading and\ntrailing spaces and a sign.)\n\nWhen called with `base`, then `e` must be a string to be interpreted as an\ninteger numeral in that base. The base may be any integer between 2 and 36,\ninclusive. In bases above 10, the letter '`A`' (in either upper or lower\ncase) represents 10, '`B`' represents 11, and so forth, with '`Z`'\nrepresenting 35. If the string `e` is not a valid numeral in the given base,\nthe function returns nil
tostring _G.tostring(v)\nReceives a value of any type and converts it to a string in a human-readable\nformat. Floats always produce strings with some floating-point indication\n(either a decimal dot or an exponent). (For complete control of how numbers\nare converted, use `string.format`.)\n\nIf the metatable of `v` has a `"__tostring"` field, then `tostring` calls the\ncorresponding value with `v` as argument, and uses the result of the call as\nits result.
traceback debug.traceback([thread, ] [message] [, level])\nIf `message` is present but is neither a string nor nil, this function\nreturns `message` without further processing. Otherwise, it returns a string\nwith a traceback of the call stack. The optional `message` string is appended\nat the beginning of the traceback. An optional `level` number tells at which\nlevel to start the traceback (default is 1, the function calling\n`traceback`).
type _G.type(v)\nReturns the type of its only argument, coded as a string. The possible\nresults of this function are "\n`nil`" (a string, not the value nil), "`number`", "`string`", "`boolean`",\n"`table`", "`function`", "`thread`", and "`userdata`".
type io.type(obj)\nChecks whether `obj` is a valid file handle. Returns the string `"file"`\nif `obj` is an open file handle, `"closed file"` if `obj` is a closed file\nhandle, or nil if `obj` is not a file handle.
type math.type(x)\nReturns "integer" if `x` is an integer, "float" if it is a float, or nil if\nx is not a number.\n\nNew in Lua 5.3.
ult math.ult(m, n)\nReturns a boolean, true if integer `m` is below integer `n` when they are\ncompared as unsigned integers.\n\nNew in Lua 5.3.
unpack _G.unpack(list [, i [, j]])\nReturns the elements from the given table. This function is equivalent to\nreturn list[i], list[i+1], ···, list[j] except that the above code can\nbe written only for a fixed number of elements. By default, `i` is 1 and\n`j` is the length of the list, as defined by the length operator\n(see §2.5.5).\n\nDeprecated in Lua 5.2.
unpack string.unpack(fmt, s [, pos])\nReturns the values packed in string `s` (see `string.pack`) according to the\nformat string `fmt` (see §6.4.2). An optional `pos` marks where to start\nreading in `s` (default is 1). After the read values, this function also\nreturns the index of the first unread byte in `s`.\n\nNew in Lua 5.3.
unpack table.unpack(list [, i [, j]])\nReturns the elements from the given list. This function is equivalent to\n\n  return list[i], list[i+1], ···, list[j]\n\nBy default, `i` is 1 and `j` is `#list`.\n\nNew in Lua 5.2.
unsplit view.unsplit(view)\nUnsplits the view if possible, returning `true` on success.\n@param view The view to unsplit.\n@return boolean if the view was unsplit or not.
upper string.upper(s)\nReceives a string and returns a copy of this string with all lowercase\nletters changed to uppercase. All other characters are left unchanged. The\ndefinition of what a lowercase letter is depends on the current locale.
upvalueid debug.upvalueid(f, n)\nReturns a unique identifier (as a light userdata) for the upvalue numbered\n`n` from the given function.\n\nThese unique identifiers allow a program to check whether different closures\nshare upvalues. Lua closures that share an upvalue (that is, that access a\nsame external local variable) will return identical ids for those upvalue\nindices.\n\nNew in Lua 5.2.
upvaluejoin debug.upvaluejoin(f1, n1, f2, n2)\nMake the `n1`-th upvalue of the Lua closure `f1` refer to the `n2`-th upvalue\nof the Lua closure `f2`.\n\nNew in Lua 5.2.
utf8 _G.utf8 (module)\nLua utf8 module.
view _G.view (table)\nThe current view.
wait spawn_proc:wait()\nBlocks until process *spawn_proc* finishes.
wrap coroutine.wrap(f)\nCreates a new coroutine, with body `f`. `f` must be a Lua\nfunction. Returns a function that resumes the coroutine each time it is\ncalled. Any arguments passed to the function behave as the extra arguments to\n`resume`. Returns the same values returned by `resume`, except the first\nboolean. In case of error, propagates the error.
write file:write(···)\nWrites the value of each of its arguments to `file`. The arguments must be\nstrings or numbers.\n\nIn case of success, this function returns `file`. Otherwise it returns nil\nplus a string describing the error.
write io.write(···)\nEquivalent to `io.output():write(···)`.
write spawn_proc:write(...)\nWrites string input to the stdin of process *spawn_proc*.\nNote: On Linux, if more than 65536 bytes (64K) are to be written, it is\npossible those bytes need to be written in 65536-byte (64K) chunks, or the\nprocess may not receive all input. However, it is also possible that there is\na limit on how many bytes can be written in a short period of time, perhaps\n196608 bytes (192K).\n@param ... Standard input for *spawn_proc*.
xor bit32.xor(...)\nReturns the bitwise "exclusive or" of its operands.\n\nNew in Lua 5.2.\nDeprecated in Lua 5.3.
xpcall _G.xpcall(f, msgh [, arg1, ···])\nThis function is similar to `pcall`, except that it sets a new message\nhandler `msgh`.
yield coroutine.yield(···)\nSuspends the execution of the calling coroutine. Any arguments to `yield` are\npassed as extra results to `resume`.
terralib _G.terralib (module)\nLua module for interraction with Terra.
newlist terralib.newlist([lst])\nCreates a new list. lst is an optional table to use as the initializer.
islist terralib.islist(exp)\nTrue if exp is a list.
israwlist terralib.israwlist(l)\nReturns true if l is a table that has no keys or has a contiguous\nrange of integer keys from 1 to N for some N, and contains no other keys.
isfunction terralib.isfunction(obj)\nTrue if obj is a Terra function.
isconstant terralib.isconstant(obj)\nTrue if obj is a Terra constant.
ismacro terralib.ismacro(t)\nTrue if t is a macro.
isquote terralib.isquote(t)\nReturns true if t is a quote.
issymbol terralib.issymbol(s)\nTrue if s is a symbol.
istype terralib.types.istype(t)\nTrue if t is a type.
newstruct terralib.types.newstruct([displayname])\ndisplayname is an optional name that will be displayed by error messages,\nbut each call to newstruct creates a unique type regardless of name\n(We use a nominative type system.\nThe type can then be used in Terra programs.
includecstring terralib.includecstring(code,[args,target])\nImport the string code as C code.\nReturns a Lua table mapping the names of included C functions to Terra function objects,\nand names of included C types (e.g. typedefs) to Terra types.
includec terralib.includec(filename,[args,target])\nSimilar to includecstring except that C code is loaded from filename.
includepath terralib.includepath\nThe Lua variable terralib.includepath can be used to add additional paths to the header search. It is a semi-colon separated list of directories to search.
linklibrary terralib.linklibrary(filename)\nLoad the dynamic library in file  filename.\nIf header files imported with includec contain declarations whose definitions are not linked into the executable in which Terra is run,\nthen it is necessary to dynamically load the definitions with linklibrary.
linkllvm terralib.linkllvm(filename)\nLink an LLVM bitcode file filename with extension .bc generated with clang or clang++.
typeof terralib.typeof(obj)\nReturn the Terra type of obj.\nObject must be a LuaJIT ctype that was previously allocated using calls into the Terra API, or as the return value of a Terra function.
new terralib.new(terratype,[init])\nWrapper around LuaJIT’s ffi.new.\nAllocates a new object with the type terratype.\ninit is an optional initializer that follows the rules for converting between Terra values and Lua values.\nThis object will be garbage collected if it is no longer reachable from Lua.
sizeof terralib.sizeof(terratype)\nWrapper around ffi.typeof.\nCompletes the terratype and returns its size in bytes.
offsetof terralib.offsetof(terratype,field)\nWrapper around ffi.offsetof.\nCompletes the terratype and returns the offset in bytes of field inside terratype.
cast terralib.cast(terratype,obj)\nWrapper around ffi.cast.\nConverts obj to terratype using the rules\nfor converting between Terra values and Lua values.
load terralib.load(readerfn)\nLua equivalent of C API call terra_load.\nreaderfn behaves the same as in Lua’s load function.
loadstring terralib.loadstring(s)\nLua equivalent of C API call terra_loadstring.
loadfile terralib.loadfile(filename)\nLua equivalent of C API call terra_loadfile.
require require(modulename)\nLoad the terra code modulename. Terra adds an additional code loader to Lua’s package.loaders to handle the loading of Terra code as a module.\nrequire first checks if modulename has already been loaded by a previous call to require, returning the previously loaded results if available.\nOtherwise it searches package.terrapath for the module.\npackage.terrapath is a semi-colon separated list of templates.
saveobj terralib.saveobj(filename [, filetype], functiontable[, arguments, target])\nSave Terra code to an external representation such as an object file, or executable.
newtarget terralib.newtarget(table)\nThe functions terralib.saveobj and terralib.includec take an optional target object, that tells the compiler to compile the code for a different architecture. These targets can be used for cross-compilation.
currenttimeinseconds terralib.currenttimeinseconds()\nA Lua function that returns the current time in seconds\nsince some fixed time in the past. Useful for performancing tuning Terra code.
traceback terra terralib.traceback(uctx : &opaque)\nA Terra function that can be called from Terra code to print a stack trace.
backtrace terra terralib.backtrace(addresses : &&opaque, naddr : uint64, ip : &opaque, frameaddress : &opaque)
disas terra terralib.disas(addr : &opaque, nbytes : uint64, ninst : uint64)
lookupsymbol terra terralib.lookupsymbol(ip : &opaque, addr : &&opaque, size : &uint64, name : &rawstring, namelength : &uint64) : bool
lookupline terra terralib.lookupline(fnaddr : &opaque, ip : &opaque, filename : &rawstring, namelength : &uint64, line : &uint64) : bool
global global([type], [init])\nCreates a new global variable of type type given the initial value init.\nEither type or init must be specified.\nIf type is not specified we attempt to infer it from init.
array array(...)\nThe function array will construct an array from a variable number of arguments.
arrayof arrayof(type,...)\nIf you want to specify a particular type for the elements of the array you can use arrayof function.
vector vector(...)\nThe function vector will construct a vector from a variable number of arguments.
vector vector(type,N)\nConstructs a vector of N instances of type typ.\nN must be an integer and typ must be a primitive type.\nThese types are abstractions vector instruction sets like SSE.
vectorof vectorof(type,...)\nConstruct a vector of type [type].
constant constant([type],init)\nCreate a new constant. init is converted to a Terra value using the normal conversion rules.\nIf the optional type is specified, then init is converted to that type explicitly.\nCompletes the type.
macro macro(function(arg0,arg1,...,argN) [...] end)\nCreate a new macro. The function will be invoked at compile time for each call in Terra code.\nEach argument will be a Terra quote representing the argument.
symbol symbol([typ],[displayname])\nConstruct a new symbol.\nThis symbol will be unique from any other symbol.\ntyp is an optional type for the symbol.\nIf the symbol is used in a variable definition without an explicit type, then the variable will use typ as its type.\ndisplayname is an optional name that will be printed\nout in error messages when this symbol is encountered.
tuple tuple(type0,type1,...,typeN)\nConstructs a tuple, which is a special kind of struct that contains the values\ntype0… typeN as fields obj._0 …. obj._N.\nUnlike normal structs, each call to tuple with the same arguments will return the same type.